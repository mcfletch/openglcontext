# -*- coding: ISO-8859-1 -*-
"""Resource phongprecalc_vert (from file phongprecalc.vert)"""
# written by resourcepackage: (1, 0, 1)
source = 'phongprecalc.vert'
package = 'OpenGLContext.resources'
data = (b'// Vertex-shader pre-calculation for blinn-phong lighting\nvo'
+b'id phong_preCalc( \n    in vec3 vertex_position,\n    in vec4 '
+b'light_position,\n    out float light_distance,\n    out vec3 e'
+b'c_light_location,\n    out vec3 ec_light_half\n) {\n    // This'
+b' is the core setup for a phong lighting pass as a reusable f'
+b'ragment of code.\n    \n    // vertex_position -- un-transform'
+b'ed vertex position (world-space)\n    // light_position -- un'
+b'-transformed light location (direction)\n    // light_distanc'
+b'e -- output giving world-space distance-to-light \n    // ec_'
+b'light_location -- output giving location of light in eye coo'
+b'rds \n    // ec_light_half -- output giving the half-vector o'
+b'ptimization\n    \n    if (light_position.w == 0.0) {\n        '
+b'// directional rather than positional light...\n        ec_li'
+b'ght_location = normalize(\n            gl_NormalMatrix *\n    '
+b'        light_position.xyz\n        );\n        light_distance'
+b' = 0.0;\n    } else {\n        // positional light, we calcula'
+b'te distance in \n        // model-view space here, so we take'
+b' a partial \n        // solution...\n        vec3 ms_vec = (\n '
+b'           light_position.xyz -\n            vertex_position\n'
+b'        );\n        vec3 light_direction = gl_NormalMatrix * '
+b'ms_vec;\n        ec_light_location = normalize( light_directi'
+b'on );\n        light_distance = abs(length( ms_vec ));\n    }\n'
+b'    // half-vector calculation \n    ec_light_half = normaliz'
+b'e(\n        ec_light_location - vec3( 0,0,-1 )\n    );\n}\n')
### end
