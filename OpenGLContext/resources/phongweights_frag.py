# -*- coding: ISO-8859-1 -*-
"""Resource phongweights_frag (from file phongweights.frag)"""
# written by resourcepackage: (1, 0, 1)
source = 'phongweights.frag'
package = 'OpenGLContext.resources'
data = (b'vec3 phong_weightCalc( \n    in vec3 light_pos, // light posi'
+b'tion/direction\n    in vec3 half_light, // half-way vector be'
+b'tween light and view\n    in vec3 frag_normal, // geometry no'
+b'rmal\n    in float shininess, // shininess exponent\n    in fl'
+b'oat distance, // distance for attenuation calculation...\n   '
+b' in vec4 attenuations, // attenuation parameters...\n    in v'
+b'ec4 spot_params, // spot control parameters...\n    in vec4 s'
+b'pot_direction // model-space direction\n) {\n    // Together w'
+b'ith phong_preCalc this is the core blinn/phong \n    // light'
+b'ing algorithm.  The light_pos, half_light, and distance \n   '
+b' // parameters were calculated by phong_preCalc, frag_normal'
+b'\n    // is normally calculated by the vertex shader (we pass'
+b' it as \n    // baseNormal).  shininess normally comes from t'
+b'he material, \n    // while attenuations, spot_params and spo'
+b't_direction come \n    // from the lighting setup.\n    \n    /'
+b'/ returns vec3( ambientMult, diffuseMult, specularMult )\n   '
+b' \n    float n_dot_pos = max( 0.0, dot( \n        frag_normal,'
+b' light_pos\n    ));\n    float n_dot_half = 0.0;\n    float att'
+b'enuation = 1.0;\n    if (n_dot_pos > -.05) {\n        float sp'
+b'ot_effect = 1.0;\n        if (spot_params.w != 0.0) {\n       '
+b'     // is a spot...\n            float spot_cos = dot(\n     '
+b'           gl_NormalMatrix * normalize(spot_direction.xyz),\n'
+b'                normalize(-light_pos)\n            );\n       '
+b'     if (spot_cos <= spot_params.x) {\n                // is '
+b'a spot, and is outside the cone-of-light...\n                '
+b'return vec3( 0.0, 0.0, 0.0 );\n            } else {\n         '
+b'       if (spot_cos == 1.0) {\n                    spot_effec'
+b't = 1.0;\n                } else {\n                    spot_e'
+b'ffect = pow( \n                        (1.0-spot_params.x)/(1'
+b'.0-spot_cos), \n                        spot_params.y \n      '
+b'              );\n                }\n            }\n        }\n '
+b'       n_dot_half = pow(\n            max(0.0,dot( \n         '
+b'       half_light, frag_normal\n            )), \n            '
+b'shininess\n        );\n        if (distance != 0.0) {\n        '
+b'    attenuation = spot_effect / (\n                    attenu'
+b'ations.x + \n                    (attenuations.y * distance) '
+b'+\n                    (attenuations.z * distance * distance)'
+b'\n                );\r\n            attenuation = clamp( attenu'
+b'ation, 0.0, 1.0 );\n            n_dot_pos *= attenuation;\n   '
+b'         n_dot_half *= attenuation;\r\n        }\n    }\r\n    re'
+b'turn vec3( attenuation, n_dot_pos, n_dot_half);\n}\n')
### end
