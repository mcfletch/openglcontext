<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="content-type"
 content="text/html; charset=ISO-8859-1">
  <title>NeHe6 for OpenGLContext</title>
  <link rel="stylesheet" type="text/css" href="style/tutorial.css">
  <meta name="author" content="Mike C. Fletcher">
</head>
<body>
<h1>NeHe6 for OpenGLContext</h1>
<p class="introduction">This&nbsp;document discusses the <a
 href="http://nehe.gamedev.net/tutorials/lesson.asp?l=06">NeHe6 tutorial</a>
by Jeff Molofee. &nbsp;It introduces texture mapping using PIL to load
Images, and the use of the OnInit customisation point for Contexts.</p>
<p>See <a href="nehe5.html">NeHe5</a> for discussion of the Context
setup procedure here...<br>
</p>
<pre>from OpenGLContext import testingcontext<br>BaseContext, MainFunction = testingcontext.getInteractive()<br>from OpenGL.GL import *<br>import time<br></pre>
<p>We will use PIL's "open" function to open the image we are going to
use as a texture (the tutorial uses auxDIBImageLoad, PIL gives us
considerably more flexibility and is fairly easy to use). &nbsp;Once
we've imported "open", we continue with our normal initialisation.</p>
<pre>from Image import open<br><br>class TestContext( BaseContext ):<br>	# set initial camera position, tutorial does the re-positioning<br>	initialPosition = (0,0,0)<br></pre>
<p>The OnInit customisation point is called after the Context has been
initialised, but before any rendering passes are attempted. &nbsp;It
allows you to setup global resources, start new worker threads and the
like. &nbsp;In this case we use it to load the PIL image,&nbsp; compile
it to a texture ID, and store that texture ID for the rendering passes.</p>
<pre>	def OnInit( self ):<br>		"""Load the image on initial load of the application"""<br>		self.imageID = self.loadImage ()<br></pre>
<p>The loadImage method is just used to factor out the image loading
and compiling stage, it could just as easily have been done directly in
the OnInit method. &nbsp;See the tutorial for explanations of the
various OpenGL functions used.</p>
<pre>	def loadImage( self, imageName = "nehe_wall.bmp" ):<br>		"""Load an image file as a 2D texture using PIL<br><br>		This method combines all of the functionality required to<br>		load the image with PIL, convert it to a format compatible<br>		with PyOpenGL, generate the texture ID, and store the image<br>		data under that texture ID.<br><br>		Note: only the ID is returned, no reference to the image object<br>		or the string data is stored in user space, the data is only<br>		present within the OpenGL engine after this call exits.<br>		"""<br>		im = open(imageName)<br>		try:<br>			# get image meta-data (dimensions) and data<br>			ix, iy, image = im.size[0], im.size[1], im.tostring("raw", "RGBA", 0, -1)<br>		except SystemError:<br>			# has no alpha channel, synthesize one, see the<br>			# texture module for more realistic handling<br>			ix, iy, image = im.size[0], im.size[1], im.tostring("raw", "RGBX", 0, -1)<br>		# generate a texture ID<br>		ID = glGenTextures(1)<br>		# make it current<br>		glBindTexture(GL_TEXTURE_2D, ID)<br>		glPixelStorei(GL_UNPACK_ALIGNMENT,1)<br>		# copy the texture into the current texture ID<br>		glTexImage2D(GL_TEXTURE_2D, 0, 3, ix, iy, 0, GL_RGBA, GL_UNSIGNED_BYTE, image)<br>		# return the ID for use<br>		return ID<br></pre>
<p>Render is as seen before, save that we don't have a pyramid, and we
call setupTexture before rendering the cube.<br>
</p>
<pre>	def Render( self, mode = 0):<br>		"""Render scene geometry"""<br>		BaseContext.Render( self, mode )<br>		glDisable( GL_LIGHTING) # context lights by default<br>		glTranslatef(1.5,0.0,-6.0);<br>		glRotated( time.time()%(8.0)/8 * -360, 1,0,0)<br>		self.setupTexture()<br>		self.drawCube()<br>	def OnIdle( self, ):<br>		"""Request refresh of the context whenever idle"""<br>		self.triggerRedraw(1)<br>		return 1<br></pre>
<p>setupTexture does the render-time setup of the texture (makes it
actually affect the rendered geometry).</p>
<pre>	def setupTexture( self ):<br>		"""Render-time texture environment setup<br><br>		This method encapsulates the functions required to set up<br>		for textured rendering.  The original tutorial made these<br>		calls once for the entire program.  This organization makes<br>		more sense if you are likely to have multiple textures.<br>		"""<br>		# texture-mode setup, was global in original<br>		glEnable(GL_TEXTURE_2D)<br>		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)<br>		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)<br>		glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL)<br>		# re-select our texture, could use other generated textures<br>		# if we had generated them earlier...<br>		glBindTexture(GL_TEXTURE_2D, self.imageID)</pre>
<p>Drawing the cube has changed slightly, because we now need to
specify the texture coordinates for each vertex. This is all just taken
from the original tutorial.</p>
<p></p>
<pre>	def drawCube( self ):<br>		"""Draw a cube with texture coordinates"""<br>		glBegin(GL_QUADS);<br>		glTexCoord2f(0.0, 0.0); glVertex3f(-1.0, -1.0,  1.0);<br>		glTexCoord2f(1.0, 0.0); glVertex3f( 1.0, -1.0,  1.0);<br>		glTexCoord2f(1.0, 1.0); glVertex3f( 1.0,  1.0,  1.0);<br>		glTexCoord2f(0.0, 1.0); glVertex3f(-1.0,  1.0,  1.0);<br><br>		glTexCoord2f(1.0, 0.0); glVertex3f(-1.0, -1.0, -1.0);<br>		glTexCoord2f(1.0, 1.0); glVertex3f(-1.0,  1.0, -1.0);<br>		glTexCoord2f(0.0, 1.0); glVertex3f( 1.0,  1.0, -1.0);<br>		glTexCoord2f(0.0, 0.0); glVertex3f( 1.0, -1.0, -1.0);<br><br>		glTexCoord2f(0.0, 1.0); glVertex3f(-1.0,  1.0, -1.0);<br>		glTexCoord2f(0.0, 0.0); glVertex3f(-1.0,  1.0,  1.0);<br>		glTexCoord2f(1.0, 0.0); glVertex3f( 1.0,  1.0,  1.0);<br>		glTexCoord2f(1.0, 1.0); glVertex3f( 1.0,  1.0, -1.0);<br><br>		glTexCoord2f(1.0, 1.0); glVertex3f(-1.0, -1.0, -1.0);<br>		glTexCoord2f(0.0, 1.0); glVertex3f( 1.0, -1.0, -1.0);<br>		glTexCoord2f(0.0, 0.0); glVertex3f( 1.0, -1.0,  1.0);<br>		glTexCoord2f(1.0, 0.0); glVertex3f(-1.0, -1.0,  1.0);<br><br>		glTexCoord2f(1.0, 0.0); glVertex3f( 1.0, -1.0, -1.0);<br>		glTexCoord2f(1.0, 1.0); glVertex3f( 1.0,  1.0, -1.0);<br>		glTexCoord2f(0.0, 1.0); glVertex3f( 1.0,  1.0,  1.0);<br>		glTexCoord2f(0.0, 0.0); glVertex3f( 1.0, -1.0,  1.0);<br><br>		glTexCoord2f(0.0, 0.0); glVertex3f(-1.0, -1.0, -1.0);<br>		glTexCoord2f(1.0, 0.0); glVertex3f(-1.0, -1.0,  1.0);<br>		glTexCoord2f(1.0, 1.0); glVertex3f(-1.0,  1.0,  1.0);<br>		glTexCoord2f(0.0, 1.0); glVertex3f(-1.0,  1.0, -1.0);<br>		glEnd()<br></pre>
<p>Make the script run MainFunction with an instance of our TestContext
if the module is run as a script.<br>
</p>
<pre>if __name__ == "__main__":<br>	## We only want to run the main function if we<br>	## are actually being executed as a script<br>	MainFunction ( TestContext)<br></pre>
<p>You can find the complete code for this sample in
OpenGLContext/tests/nehe6.py<br>
</p>
<p class="footer"><a href="documentation.html"><img
 src="images/doc_icon.gif" title="" alt="Documentation"
 style="border: 0px solid ; width: 32px; height: 32px;" align="middle"></a> <a
 href="http://pyopengl.sourceforge.net/context/"><img
 src="images/context_logo_icon.png" title="" alt="OpenGLContext"
 style="border: 0px solid ; width: 32px; height: 32px;" align="middle"></a> <a
 href="http://pyopengl.sourceforge.net/"><img align="middle" title=""
 alt="PyOpenGL" src="images/pyopengl_icon.jpg"
 style="border: 0px solid ; width: 32px; height: 32px;"></a> A
SourceForge Open-Source project: <a href="http://sourceforge.net"><img
 src="http://sourceforge.net/sflogo.php?group_id=5988&amp;type=1"
 style="border: 0px solid ; width: 88px; height: 31px;"
 alt="SourceForge" title="" align="middle"></a></p>
</body>
</html>
