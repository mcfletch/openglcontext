<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
<title>Special Effects: Shadows in FrameBufferObject</title>
    <link href="./tutorial.css" type="text/css" rel="stylesheet" />
</head>
<body>
<table width="100%" class="navtable"><thead>
	<tr>
		<td width="8em;"></td><th align="center"><a href="index.xhtml">OpenGLContext Python tutorials</a></th><td width="8em;"></td>
	</tr>
	<tr>
	<td><a href="shadow_1.xhtml">Previous</a></td>
	<td align="center">Special Effects: Shadows in FrameBufferObject</td>
	<td align="right"><a href="index.xhtml">Index</a></td>
	</tr>
</thead></table>
	<div class="code-sample">#! /usr/bin/env python
</div>
	<div class="commentary">
	<h1 class="title">Shadows in FrameBufferObject</h1>
	<div class="paragraph">
	<img src="shadow_2.py-screen-0001.png" alt="Screenshot" class=" wiki" />
</div>
	<div class="paragraph">In this tutorial, we will:</div>
	<ul class="">
	<li class="">subclass our previous shadow tutorial code </li>
	<li class="">use Frame Buffer Objects to render the depth-texture </li>
	<li class="">render to a larger texture than the screen-size</li>
</ul>
	<div class="paragraph">This tutorial is a minor revision of our previous shadow tutorial,
the only change is to add off-screen rendering of the depth-texture 
rather than rendering on the back-buffer of the screen.
</div>
</div>
	<div class="code-sample">import OpenGL,sys,os,traceback
from OpenGLContext import testingcontext
</div>
	<div class="commentary">
	<div class="paragraph">Import the previous tutorial as BaseContext</div>
</div>
	<div class="code-sample">from shadow_1 import TestContext as BaseContext
from OpenGLContext.scenegraph.basenodes import *
from OpenGL.GL import *
from OpenGL.GLU import *
from OpenGL.GL.ARB.depth_texture import *
from OpenGL.GL.ARB.shadow import *
</div>
	<div class="commentary">
	<div class="paragraph">Import the PyOpenGL convenience wrappers for the FrameBufferObject
extension(s) we're going to use.  (Requires PyOpenGL 3.0.1b2 or above).</div>
</div>
	<div class="code-sample">from OpenGL.GL.framebufferobjects import *
from OpenGLContext.arrays import (
    array, sin, cos, pi, dot, transpose,
)
from OpenGLContext.events.timer import Timer
class TestContext( BaseContext ):
    """Shadow rendering tutorial code"""
    def OnInit( self ):
        """Scene set up and initial processing"""
        super( TestContext, self ).OnInit()
</div>
	<div class="commentary">
	<div class="paragraph">We'll use the slightly more idiomatic "check if the entry 
        point is true" way of checking for the extension.  The alternates
        in the convenience wrapper will report true if there is any 
        implementation of the function.</div>
</div>
	<div class="code-sample">        if not glBindFramebuffer:
            print 'Missing required extensions!'
            sys.exit( testingcontext.REQUIRED_EXTENSION_MISSING )
</div>
	<div class="commentary">
	<div class="paragraph">Decide how big our depth-texture should be...</div>
</div>
	<div class="code-sample">        self.shadowMapSize = min(
            (
                glGetIntegerv( GL_MAX_TEXTURE_SIZE ),
                2048,
            )
        )
        if self.shadowMapSize &lt; 256:
            print 'Warning: your hardware only supports extremely small textures!'
        print 'Using shadow map of %sx%s pixels'%( 
            self.shadowMapSize,self.shadowMapSize 
        )
</div>
	<div class="commentary">
	<div class="paragraph">As before, we want to store our depth-texture between rendering 
    passes.  The new item is the FrameBufferObject which represents the 
    off-screen context into which we will be rendering.</div>
</div>
	<div class="code-sample">    shadowFBO = None 
    shadowColor = None
    shadowTexture = None
</div>
	<div class="commentary">
	<div class="paragraph">We override this default in the init function.</div>
</div>
	<div class="code-sample">    shadowMapSize = 2048
</div>
	<div class="commentary">
	<div class="paragraph">Should you wish to experiment with different filtering functions,
    we'll parameterize the filtering operation here.</div>
</div>
	<div class="code-sample">    FILTER_TYPE = GL_NEAREST 
    def setupShadowContext( self ):
        """Create a shadow-rendering context/texture"""
        shadowMapSize = self.shadowMapSize
        if not self.shadowFBO:
</div>
	<div class="commentary">
	<div class="paragraph">Creating FBOs is expensive, so we want to create and configure 
            our FBO once and reuse it.</div>
</div>
	<div class="code-sample">            self.shadowFBO = glGenFramebuffers(1)
</div>
	<div class="commentary">
	<div class="paragraph">It has to be bound to configure it.</div>
</div>
	<div class="code-sample">            glBindFramebuffer(GL_FRAMEBUFFER, self.shadowFBO )
</div>
	<div class="commentary">
	<div class="paragraph">The creation of a colour render buffer would not seem to be 
            necessary, after all, we are filtering out all of the colour-buffer 
            updates.  Unfortunately, at least on ATI's 3xxx series, it seems 
            there must be a colour buffer even if there are no updates to it.
</div>
</div>
	<div class="code-sample">            self.shadowColor = glGenRenderbuffers(1)
            glBindRenderbuffer(GL_RENDERBUFFER, self.shadowColor)
</div>
	<div class="commentary">
	<div class="paragraph">We are not going to actually use the buffer, so rather than 
            rendering to a texture, we'll just allocate the storage on the 
            back-end.  Note that if we *did* need to access the values,
            we *could* do a glCopyTexSubImage2D as we did in the previous
            tutorial, but that would obviate much of  the value of the FBO
            approach.  What it *would* do is allow us to use a 
            Multisampling buffer.  If you want to do antialiased off-screen 
            rendering you'll likely need that approach.
</div>
</div>
	<div class="code-sample">            glRenderbufferStorage(
                GL_RENDERBUFFER,
                GL_RGBA4,
                shadowMapSize,
                shadowMapSize,
            )
</div>
	<div class="commentary">
	<div class="paragraph">Now we attach our newly-created colour buffer to the FBO object,
            which makes it the (first) colour rendering buffer for the virtual
            context the FBO represents.  As noted above, while it wouldn't seem 
            necessary, real-world tests suggest that there always needs to be 
            at least one colour-buffer attached.</div>
</div>
	<div class="code-sample">            glFramebufferRenderbuffer(
                GL_FRAMEBUFFER,
                GL_COLOR_ATTACHMENT0,
                GL_RENDERBUFFER,
                self.shadowColor,
            )
        else:
</div>
	<div class="commentary">
	<div class="paragraph">We've already got the FBO with its colour buffer, just bind to 
            render into it.</div>
</div>
	<div class="code-sample">            glBindFramebuffer(GL_FRAMEBUFFER, self.shadowFBO )
        if not self.shadowTexture:
</div>
	<div class="commentary">
	<div class="paragraph">The texture itself is the same as the last tutorial.</div>
</div>
	<div class="code-sample">            texture = glGenTextures( 1 )
            glBindTexture( GL_TEXTURE_2D, texture )
            glTexImage2D( 
                GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, 
                shadowMapSize, shadowMapSize, 0,
                GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, None
            )
            self.shadowTexture = texture
</div>
	<div class="commentary">
	<div class="paragraph">We attach the texture to the FBO's depth attachment point.  There 
            is also a combined depth-stencil attachment point when certain 
            extensions are available.  We don't actually need a stencil buffer 
            just now, so we can ignore that.</div>
	<div class="paragraph">The final argument is the "mip-map-level" of the texture,
which currently always must be 0.
</div>
</div>
	<div class="code-sample">            glFramebufferTexture2D(
                GL_FRAMEBUFFER, 
                GL_DEPTH_ATTACHMENT, 
                GL_TEXTURE_2D, 
                texture, 
                0 #mip-map level...
            )
        else:
</div>
	<div class="commentary">
	<div class="paragraph">Just make the texture current to configure parameters.</div>
</div>
	<div class="code-sample">            texture = self.shadowTexture
            glBindTexture( GL_TEXTURE_2D, texture )
        glPushAttrib(GL_VIEWPORT_BIT)
</div>
	<div class="commentary">
	<div class="paragraph">We use the same "nearest" filtering as before</div>
</div>
	<div class="code-sample">        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, self.FILTER_TYPE)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP)
</div>
	<div class="commentary">
	<div class="paragraph">Unlike in the previous tutorial, we now *know* this is a 
        valid size for the viewport in the off-screen context.</div>
</div>
	<div class="code-sample">        glViewport(0,0,shadowMapSize,shadowMapSize)
</div>
	<div class="commentary">
	<div class="paragraph">This function in the OpenGL.GL.framebufferobjects wrapper will 
        raise an OpenGL.error.GLError if the FBO is not properly configured.</div>
</div>
	<div class="code-sample">        checkFramebufferStatus( )
</div>
	<div class="commentary">
	<div class="paragraph">Un-bind the texture so that regular rendering isn't trying to 
        lookup a texture in our depth-buffer-bound texture.</div>
</div>
	<div class="code-sample">        glBindTexture( GL_TEXTURE_2D, 0 )
</div>
	<div class="commentary">
	<div class="paragraph">Clear the depth buffer (texture) on each pass.</div>
</div>
	<div class="code-sample">        glClear(GL_DEPTH_BUFFER_BIT)
        return texture
    def closeShadowContext( self, texture ):
        """Close our shadow-rendering context/texture"""
</div>
	<div class="commentary">
	<div class="paragraph">This is a very simple function now, we just disable the FBO,
        and restore the viewport.</div>
</div>
	<div class="code-sample">        glBindFramebuffer(GL_FRAMEBUFFER, 0 )
        glPopAttrib(GL_VIEWPORT_BIT)
        return texture
if __name__ == "__main__":
</div>
	<div class="commentary">
	<div class="paragraph">Our display size is now irrelevant to our rendering algorithm, so we 
    won't bother specifying a size.</div>
</div>
	<div class="code-sample">
    TestContext.ContextMainLoop()
</div>
<div class="source-reference">This code-walkthrough tutorial is generated from the shadow_2.py script in the 
OpenGLContext source distribution.</div>
<table width="100%" class="navtable"><thead>
	<tr>
		<td width="8em;"></td><th align="center"><a href="index.xhtml">OpenGLContext Python tutorials</a></th><td width="8em;"></td>
	</tr>
	<tr>
	<td><a href="shadow_1.xhtml">Previous</a></td>
	<td align="center">Special Effects: Shadows in FrameBufferObject</td>
	<td align="right"><a href="index.xhtml">Index</a></td>
	</tr>
	<tr class="meta-links">
		<td colspan="3">
		<a href="../documentation.html"><img src="../images/doc_icon.gif" alt="Documentation" style="border: 0px solid ; width: 32px; height: 32px;" title="" /></a> 
		<a href="http://pyopengl.sourceforge.net/context/"><img src="../images/context_logo_icon.png" alt="OpenGLContext" style="border: 0px solid ; width: 32px; height: 32px;" title="" /></a> 
		<a href="http://pyopengl.sourceforge.net/"><img src="../images/pyopengl_icon.jpg" alt="PyOpenGL" style="border: 0px solid ; width: 32px; height: 32px;" title="" /></a>
		<a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=5988&amp;type=1" style="border: 0px solid ; width: 88px; height: 31px;" alt="SourceForge" title="" /></a>
		</td>
	</tr>
</thead></table>
</body>
</html>